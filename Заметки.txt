Вью это набор 

Вью создан в парадигме реактивного программирования

Вью работает с виртуальным DOM , это улучшает производительность приложения

Виртуальная копия реального дом-дерева 

При изменении реального дом-дерева, сначала меняется реальное дом-дерево, потом вью сравнивает состояние реального и виртуального дом-дерева,
ищет оптимальный путь, чтобы реальное дом дерево соответстовало виртуальному 
Вью не будет работать со всем body 

Для Вью 

Атрибут v-model связывает пользовательский ввод или вывод с каким то свойством, из объекта который возвращает метод data

Интерполяция текста - вставка текста в HTML из JS
сли нужно вывести значения, нужно поставить {{}}  вписать туда переменную которую хотим вывести

метод .mount монтирует экземпляр vue (возвращает)

в фигурных скобках можно выводить переменных, или любое валидное JS выражение (a+b, тернарные операторы и тд.)

Всё что мы запишем в globalProperties будут доступны всем компонентам Vue

v-for - перебор 


Занятие 2

Добавление обработчика события:

v-on: click=""
@click=""

Если мы работает с Vue, можно работать обычные атрибуты из html 

Если привязка класса идет в таком виде v-bind: class="color" - то это имя свойства из объекта Vue 

класс active должен быть в css - имя класса, currentTab === tab, условие при котором класс добавитсяя к элементу 

Если метод не принимает аргументов, то пишем название метода (без круглых скобок)
Если метод принимает аргументы, то ставим крглые скобки и пишем любые аргументы

Все методы которые должны сработать при наступлении каких-то событий описываются в объекте methods 

В значение:key уникальное значение из элементов массива

Вычисляемые свойства будут пересчитываться, когда изменитя значение myList (Lesson2)

ДЗ: методы оброботчика событий, v-show, v-if, v-for зачем нуен key, привязка атрибутов, привязка классов, 


Занятие 3

v-model.trim= - удаляет пробелы сначала и сконца строки 

при любом множественном выборе (чекбоксов, селектов) будет сохранять данные в массив

при работе с Vue и с v-model выбор по умолчанию селектов и чекбоксов - работать не будет (игнорируется)

v-model.number= - преобразует в число данные из формы ( для чисел)

если у импутов одинаковое значение name , это группа чекбоксов 

У чекбоксов обязательно указывать value чтобы было понятно что выбрал пользователь

.prevent отмена события по умолчанию 

target - элемент на котором произошло событие, доступно у формы

Со стороны JS данные на сервер можно отправить несколькими способами:
1. XMLHttpRequest - поддерживается всеми браузерами
2. fetch() - современная и удобная, нельзя отследить сколько загружено и сколько осталось 
axios - библиотека для отправки ajax запросов (отправка без перезагрузки)

Чтобы создать promise - пишем new Promise (обещание)
-неизвестно сколько времени выполняется данная функция
- функция выполняется ассинхронно
Сама по себе функция promise принимает на вход еще 2 функции, первая функция вызываетсяя в случае успешного разрешения promise (всё хорошо внутри promise)
код выполняется без ошибок, если есть ошибки, выполняется вторая функция 
Promise не надо вызывать, код начинает выполняться сразу после создания

У Promise есть 3 состояния, первое называется pending - код в процессе выолнения (выполняется),
второе состояние fulfilled - код выполнения завершился успехом, 
третье rejected - завершил работу, но с ошибкой 

У Promise есть метод .then и метод .catch

Объявление:
let promise = new Promise(function (resolve, reject) {
    setTimeout(() => {
        let data = Math.random();
        if (data < 0.5) {
            resolve(`Код выполнился ${data}`);
        } else {
            reject(`Выполнение привело к ошибке ${data}`)
        }
    }, Math.floor(Math.random() * 20000))
});
console.log(promise)


Использование promise 
promise
    .then((successData) => {
        console.log(`SUCCESS ${successData}`);
        return {info: successData}
    })
    .then((returnData)=>{
        console.log(returnData);
    })
    .catch((errorData) => {
        console.log(`ERROR ${errorData}`)
    });

в метод .then передается функция, вызывается в случае успеха promise и копируется в первую переменную 
метод .then возвращает объект promise

в метод .catch вызывается в случае неуспеха, вызывается вторая функция 

Если функция переданная в метод then возвращает какой-то результат, то эти данные мы можем получить при втором вызове then 

async перед функцией, позволяет использовать await внутри функции 
ждет пока выполнится promise


Фунция fetch первым элементом принимает куда нужно отправить данные (адрес сервера) , вторым аргументом - настройки запроса
функция fetch возвращает promise, тип данных которые возвращает promise 

Когда запрос выполнится и мы получим объект (в виде объекта), у объекта ответа мы получим данные которые прислал сервер 
Если сервер возвращает какую-то строчку, то получить ее мы можем методом .text() , если JSON строчку, то методом JSON


Занятие 4


компоненты могут внедряться в основной компонент - глобально (в корневой), либо локально
у каждого компонента должен быть template, объект data, свои вычисляемые свойства, свои методы

Родительские компоненты могут передавать данные дочерним компонентам


Если регистрация компонентов происходит глобально, то они доступны всем остальным компонентам приложения

В этом объекте в этом же объекте после template описываем data, все вычисляемые свойства и методы, которые относятся к вычисляемому компоненту 

через :is название компонента

передача свойств дочерним компонентам:
любой родительский компонент может передать данные в дочерний компонент? свойство props: [""]

если указываем пропс таким способом, то тип данных может быть любой 

при первои и втором варианте передачи title нужно обязательно передать значение

validator должен возвращать true или false , если валидарор возвращает тру, значит значение передано правильно, если фолс - неправильно

весь код нужно помещать в template корневого компонента

если html задан через template, то Vue приходится ему каждый раз парсить и искать то что относится к Vue, это плохо для производительности, по этому
правильней всего задавать шаблон компонента через render() функцию инструкциями Vue 

Vue cli - это дополнительный инструмент, его удобно использовать, если проект пишется с нуля, облегчает разработку на Vue:
- сжимает CSS в одну строчку самостоятельно
- сжимает JS в одну строчку самостоятельно 

Современный синтаксис может перевести старый синтаксис для поддержки браузера, позволяет работать с однофайловыми компонентами (каждый элемент описан в отдельном файле с расширением .vue)
Внутри Vue cli работает настроенный WebPack (система сборки различных инструментов) 

Команндная строка: cd (пробел) Путь к папке где создать папку 
vue create (название проекта)
V3 (ждем)

папка src - исходный код проекта
assetc - храним картинки, pdf (всё что не редактируется) 
main.js - мы из Vue (нод модулей) импортируем 
App vue самый главный компонент
Все остальные компоненты складывать в папку components

Структура компонента:
<template> - описываем html
<style>  - все стили
<script> - объект компонента


Заняте 5 

Тема: Роутер (библиотека) дополнение к Vue  которая позволяет осуществлять маршрутизацию
По умолчанию роутер во Vue не входит, и во cli не входит
Можно становить через npm, либо через подключение как у Vue скрипта
Либо с помощью vue cli

package-lock - файл с деревом зависимости файлов

src - папка с исходным кодом
структура: 
components - компоненты, хранится небольшие компоненты из которых складывается страница (header, footer, карточка товара)
views - компоненты, которые отрисовываютс пользователю (страницы которые видит пользователь)
в папке роутер в файлу index.js - настройки роутера

<template> - html - во второй версии Vue должно быть один корневой элемент, все остальные теги вкладываются в него
в 3 версии может быть любое количество внутри <template>
Внутри должна быть html верстка


<template>
  
</template>

<script>
export default {
name: "Share"
}
</script>

<style>

</style>


Имя соответствует имени файла без расширения (необзяательно) 
Имя должно быть, если мы данный компонент собираемся использовать в других компонентах

<style scoped>

</style>

scoped - ограничивает стили в рамках одного компонента (тимплейта)
без scoped - для всех компонентов

Когда определили какие ссылки каким компонентам соответствуют, мы должны прописать каким ссылкам какие компоненты соответствуют index.js (папка роутер)

Фунция createRouter работает чтобы работала подгрузка компонентов (нужен всегда)

Сколько маршрутов, столько и объектов в массиве

path: (путь) - ссылка 
componennt: какой компонент должен отрисоваться при переходе по ссылке

component: () => import('../views/Share.vue') - ленивая загрузка компонентов, когда элемент будет запрошен, тогда страница и подгрузится

router должен быть подключен в main.js иначе ничего работать не будет 


Если при клике на ссылке нам нужен переход, то вместо тега <a></a> пишем <router-link></router-link>
между открывающим и закрывающим тегом, нужно прописывать что будет видеть пользователь {{}}
:to = href

v-bind - привязка атрибута 

Если мы хоти в каком-то компоненте использовать другой компонент, нужно выполнить 3 шага:
1/ Импорт import
2/ Экспорт export default { components: {} }
3/ Использование компонента <library-header></library-header> в тимплейт

 <router-view></router-view>  - место где будет отрисован компонент при переходе по ссылке
























